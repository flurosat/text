// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"golang.org/x/text/message/pipeline"
)

// TODO:
// - merge information into existing files
// - handle different file formats (PO, XLIFF)
// - handle features (gender, plural)
// - message rewriting

var (
	lang *string
	out  *string
)

func init() {
	lang = cmdUpdate.Flag.String("lang", "en-US", "comma-separated list of languages to process")
	out = cmdUpdate.Flag.String("out", "", "output file to write to")
}

var cmdUpdate = &Command{
	Run:       runUpdate,
	UsageLine: "update <package>* [-out <gofile>]",
	Short:     "merge translations and generate catalog",
}

func runUpdate(cmd *Command, config *pipeline.Config, args []string) error {
	config.Packages = args
	state, err := pipeline.Extract(config)
	if err != nil {
		return wrap(err, "extract failed")
	}
	if err := state.Import(); err != nil {
		return wrap(err, "import failed")
	}

	doNotRemoveTranslations(state)

	if err := state.Merge(); err != nil {
		return wrap(err, "merge failed")
	}
	if err := state.Export(); err != nil {
		return wrap(err, "export failed")
	}
	if *out != "" {
		return wrap(state.Generate(), "generation failed")
	}
	return nil
}

// by default this tool tries to remove translations for words, that are not
// autogenerated. This functions keeps all those translations.
func doNotRemoveTranslations(state *pipeline.State) {
	extracted := make(map[string]struct{}, len(state.Extracted.Messages))
	for _, m := range state.Extracted.Messages {
		extracted[m.Message.Msg] = struct{}{}
	}

	for _, tr := range state.Translations {
		for _, m := range tr.Messages {
			if _, ok := extracted[m.Message.Msg]; ok {
				continue
			}
			m := m
			// TODO: apply Placeholders first.
			m.Key = m.Message.Msg
			state.Extracted.Messages = append(state.Extracted.Messages, m)
		}
	}
}
